---
title: BMONZ 서비스 구축 Part 2
layout: post
permalink: /project/bmonzpart2
posttype: project
post-image: https://cdn.bouldermon.com/project/project00004/initial.jpg
description: AWS CI/CD 구성
tags:
- TECH
- AWS
- CI/CD
---

> [BMOZ 서비스 구축 Part2] 에서는 Github - CodeBuild - ECR(Elastic Container Registry) 간 연동을 구현하는 것을 목표로 한다.

### CI/CD 파이프라인
AWS의 서비스들을 이용한 빌드/테스트/배포 프로세스는 아래 그림과 같았다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/overview.png">
</p>

초기에는 springboot jar파일을 기준으로 Build & Deploy를 진행하려 했었으나, Docker image단위로 바꾸면서 ECR(Elastic Container Registry)이 추가로 필요하게 되었다. 바뀐 파이프라인은 아래와 같다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/overview_chg.png">
</p>

### ECR(Elastic Container Registry) 생성
배포 파일이 jar → docker image로 바뀌면서 image를 저장할 저장소가 필요했다. Amazon ECR을 통해 docker image를 관리할 예정이므로 저장소를 하나 생성했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/create_ecr.png">
</p>

BMONZ 개발/운영을 목적으로 만드는 저장소이므로 private으로 생성했으며 이미지 보안을 위한 이미지 스캔을 사용해보고 싶어 **Scan on push**를 선택했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/created_ecr.png">
</p>

이렇게 생성된 ECR에는 추후 만들 *buildspec.yml*을 통해 docker image가 저장될 예정이다.

### CodeBuild
**CodeBuild를 통한 빌드 자동화**를 구현하기 위해 필요한 작업은 총 다섯 가지이다.

- Github 저장소 브랜치 설정
- CodeBuild Project 생성
- buildspec.yml 작성
- Merge 후 Build 테스트

---

#### Github 저장소 브랜치 설정
Build는 PR(Pull Request)을 통해 Merged가 될 때에만 작동하도록 제한할 예정이다. 우선 각 Branch는 PR을 통해서만 Merge될 수 있도록 설정한다. 

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/github_repo_branch_settings.png">
  <em>Settings - Branches - Add branch protection rule</em>
</p>

위 이미지와 동일하게 develop 브랜치에 대해서도 protection rule을 추가해준다. rule을 추가 했으면 **develop 브랜치와 feature 브랜치도 생성**한다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/github_repo_create_branch.png">
</p>

로컬(feature*)에서 개발하고 개발환경(develop)을 거쳐 운영(main)으로 반영될 것이기 때문이다.

---

#### CodeBuild Project 생성
Webhook을 이용해 Github의 변경사항을 탐지하여 AWS CodeBuild에서 Build를 할 수 있도록 해야 한다. [CodeBuild용 GitHub 풀 요청 및 Webhook 필터 샘플](https://docs.aws.amazon.com/ko_kr/codebuild/latest/userguide/sample-github-pull-request.html)를 참고하여 진행했다.

**Project name**과 **Description**를 작성한 후 `enable build Badge`를 체크했다. **build badge**는 '프로젝트의 최신 빌드 상태를 표시하는 내장 가능형 이미지'로, 보통 저장소 Readme.md 파일에 최신 빌드의 상태를 표시하는 데 유용하다고 한다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_configuration.png">
</p>

**Source** 부분에서 나의 Github 저장소와 CodeBuild를 연결한다. OAuth를 통해 인증했고 springboot 프로젝트가 담긴 bmonz-api.git을 지정했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_source.png">
</p>

소스 변경 후 자동으로 빌드시키기 위해 `Webhook`을 선택했다. 다만, 무분별한 Build를 방지하기 위해 Filter 조건을 지정하여 **PR(Pull Request)를 통해 브랜치에 Merge를 했을 때만** Build하도록 설정했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_webhook_filter1.png">
</p>

~~**나의 계정**으로 **개인(feature) 브랜치에서 develop 브랜치**로의 PR건에 대해서만 Build 할 수 있도록 추가 filter를 설정했다.~~
Filter 그룹의 오작동으로 현재는 모든 조건을 해제 후 테스트 중이다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_webhook_filter2.png">
</p>

CodeBuild를 실행할 환경을 설정한다. BMONZ는 Amazon Linux2 환경의 Lightsail instance에서 실행될 것이며 JAVA 21로 빌드되어야 한다. CodeBuild에서 JAVA 21로 빌드할 수 있는 이미지를 골라야 했고 [CodeBuild User Guide](https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-available.html)를 참고하여 `aws/codebuild/amazonlinux2-x86_64-standard:5.0-24.02.08`를 선택했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_environment.png">
</p>

**Service role**은 신규로 생성했다. 현재 단계에서는 별다른 설정을 하지 않고 추후 단계인 *IAM Policy 수정* 단계에서 권한을 추가할 예정이다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_service_role.png">
</p>

**Buildspec**은 `Use a buildspec file`을 선택했다. springboot 프로젝트에도 *buildspec.yml*을 추가할 예정이다. 

> buildspec : CodeBuild가 빌드하는 데 사용하는 YAML 형식의 빌드 명령 및 관련 설정의 모음

해당 파일은 일반적으로 소스 디렉토리의 루트에 위치시킨다. 그러나, 배포 환경별로 서로 다른 내용의 buildspec이 필요한 경우가 많고 나는 resource 디렉토리 하위에서 관리하는 것을 선호하므로 *buildspec.yml*파일의 위치가 추후에는 변경될 가능성이 높다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_buildspec.png">
</p>

**Artifacts**는 Codebuild 후 ECR에 docker image를 바로 push할 예정이므로 `No artifacts`를 선택했다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_create_build_project_artifacts.png">
</p>

CodeBuild AWS 설정을 생성한 후 마지막으로 IAM에 CodeBuild → ECR image push를 위한 정책을 추가해야 한다. [AWS 가이드](https://docs.aws.amazon.com/ko_kr/codebuild/latest/userguide/sample-docker.html)를 따라 아래 정책을 위에서 생성한 **Service Role**에 추가한다.

```json
{
		    "Effect": "Allow",
		    "Action": [
		        "ecr:BatchCheckLayerAvailability",
            "ecr:CompleteLayerUpload",
            "ecr:GetAuthorizationToken",
            "ecr:InitiateLayerUpload",
            "ecr:PutImage",
            "ecr:UploadLayerPart"
        ],
        "Resource": "*"
}
```
<br/>

아래와 같이 입력하고 저장하면 AWS Console에서의 설정은 끝난다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/modify_IAM_policy_codebuild_ecr.png">
</p>

이제 프로젝트 소스에서 *buildspec.yml*을 작성해야 한다.

---

#### buildspec.yml 작성
[CodeBuild의 빌드 사양 참조](https://docs.aws.amazon.com/ko_kr/codebuild/latest/userguide/build-spec-ref.html)를 통해 기본적인 *buildspec.yml*을 작성한다. 컨셉은 `bootBuildImage`로 이미지를 생성한 후 ECR로 이미지를 Push하는 것이다.

파일을 생성하기에 앞서, **개인 브랜치(feature\*)를 체크아웃 한 후 해당 브랜치에서 *buildspec.yml*을 생성**한다. feature 브랜치에서 develop 브랜치로 MERGE하면서 CodeBuild를 테스트 할 것이다.

우선, 생성된 이미지를 Push할 ECR에 로그인 해야 한다. CodeBuild의 **Edit Environment**에서 필요한 환경변수들을 등록한다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_edit_add_environment_variables.png">
</p>

등록된 환경변수들을 사용하여 *buildspec.yml*에 ECR 로그인 command를 입력한다. `BUILD_TAG`는 Github의 어떤 커밋을 기준으로 이미지가 Build 되었는지 확인하기 위한 용도다.

```yml
phases:
  install:
    runtime-versions:
      java: corretto21
  pre_build:
    commands:
      - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
      - BUILD_TAG=${COMMIT_HASH:=latest}
      - echo Logging in to Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
  build:
    commands:
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Pushing the Docker image...
      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$BUILD_TAG
```
<br/>
`build` 부분에 `bootBuildImage` 명령어를 명시하여 springboot 프로젝트를 Dockerize한다. 마지막 부분에는 `cache` command를 변경 사항이 없는 의존성들은 캐싱하여 사용한다.

```yml
  build:
    commands:
      - echo Build started on `date`
      - echo Building the Docker image...
      - chmod +x gradlew
      - ./gradlew bootBuildImage --imageName=$IMAGE_NAME:$IMAGE_TAG
      - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$BUILD_TAG
...
...
cache:
  paths:
    - '/root/.gradle/caches/**/*'
```
<br/> 

작성이 완료된 *buildspec.yml*을 Github에 push한 후 feature 브랜치를 develop으로 MERGE 해보자.

---

### Merge 후 Build 테스트
위 설정들이 정상적으로 적용되었다면, Github에서 PR로 인한 MERGE 시 CodeBuild를 통해 빌드가 수행된다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_build_after_github_pr_merged.png">
</p>

CodeBuild가 완료되면 *buildspec.yml*에 작성되었던 `post_build`를 통해 자동으로 ECR로 docker image가 push된다.

<p align="center">
  <img src="https://cdn.bouldermon.com/project/project00004/codebuild_push_image_to_ecr.png">
</p>

### 이어서
CodeDeploy와 Lightsail instance를 연동하여 배포 프로세스를 구축한 후 CodePipeline을 통해 Github부터 Lightsail instance까지의 CI/CD 전체 프로세스를 연동한다.